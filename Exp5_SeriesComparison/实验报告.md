# 实验五：不同形式级数求和的数值稳定性比较实验报告

## 1. 实验目的
1. 实现并比较三种不同形式的调和级数求方法和
2. 观察和量化不同计算形式在数值精度上的差异
3. 理解灾难性抵消对数值计算的影响
4. 分析不同求和方法的误差增长趋势

## 2. 实验原理
### 2.1 三种级数形式
1. 交错级数形式：

$$ S_N^{(1)} = \sum_{n=1}^{2N} (-1)^n \frac{n}{n+1} $$

2. 两项求和相减形式：

$$ S_N^{(2)} = -\sum_{n=1}^{N} \frac{2n-1}{2n} + \sum_{n=1}^{N} \frac{2n}{2n+1} $$

3. 直接求和形式：

$$ S_N^{(3)} = \sum_{n=1}^{N} \frac{1}{2n(2n+1)} $$

### 2.2 相对误差计算
以 $S_N^{(3)}$ 为参考值，计算其他两种方法的相对误差：

$$ \text{Err}_1 = \left| \frac{S_N^{(1)} - S_N^{(3)}}{S_N^{(3)}} \right| $$
$$ \text{Err}_2 = \left| \frac{S_N^{(2)} - S_N^{(3)}}{S_N^{(3)}} \right| $$

## 3. 实验方法
### 3.1 代码实现
1. `sum_S1(N)` 函数实现：
   - （描述实现方法）

2. `sum_S2(N)` 函数实现：
   - （描述实现方法）

3. `sum_S3(N)` 函数实现：
   - （描述实现方法）

### 3.2 数据收集与处理
1. N值选取：使用 `np.logspace(0, 4, 50)` 在对数尺度上取点
2. 计算三种方法的求和结果
3. 计算相对误差
4. 绘制双对数误差图

## 4. 实验结果
### 4.1 数据记录
| N | $S_N^{(1)}$ | $S_N^{(2)}$ | $S_N^{(3)}$ | $\text{Err}_1$ | $\text{Err}_2$ |
|---|-------------|-------------|-------------|----------------|----------------|
| 10 |  0.28360955          |     0.28360955        |     0.28360955        |      3.91e-16          |   4.70e-15             |
| 100 |   0.30437145        |   0.30437145          |     0.30437145        |      2.55e-15          |  1.51e-13              |
| 1000 |     0.30660301     |         0.30660301    |     0.30660301        |     1.16e-14           |     5.75e-12           |
| 10000 |   0.30682782      |    0.30682782         |      0.30682782       |      5.26e-14          |     5.62e-11           |

### 4.2 误差分析图
（在此插入相对误差随N变化的双对数图）
![image](https://github.com/user-attachments/assets/c9c442ca-d9bf-40f2-9ae8-89740ab29196)

## 5. 分析与讨论
### 5.1 误差大小比较
1. 不同方法的误差比较：
   - S1 (交错级数) vs S3 (基准方法):
S1 直接计算交错级数，涉及大量正负项相加随着N增大，部分和会在较大数值间震荡导致绝对误差可能较大，但相对误差增长相对缓慢误差主要来源于浮点数累加时的舍入误差累积

     S2 (两项相减) vs S3 (基准方法):
S2 将级数分为两个独立求和部分再相减当N较大时，两个内部和都会变得很大且数值相近两个大数相减导致有效数字严重损失（灾难性抵消）因此S2的相对误差会显著大于S1
   - （分析误差增长速度）
   - S1误差增长：大致以O(1/N)速度减小因为交错级数的截断误差与最后一项同阶浮点误差累积较慢，因为正负项部分抵消
   -S2误差增长：当N > 1e3时误差快速增长符合O(N)误差增长趋势这是因为两个内部和都以O(N)速度增长，而它们的差是O(1)

2. 灾难性抵消分析：
   - （分析 $S_N^{(2)}$中两个内部和的变化）
   -  S2中两个内部和的变化
定义：
sum1 = Σ(2n-1)/(2n) ≈ Σ(1 - 1/(2n)) → N - 0.5*ln(N) + C
sum2 = Σ(2n)/(2n+1) ≈ Σ(1 - 1/(2n+1)) → N - 0.5*ln(N) + C'

渐进行为：
当N→∞时，sum1和sum2都趋近于N - 0.5*ln(N) + C''但S2 = -sum1 + sum2 = (sum2 - sum1) ≈ 0.5*(1/1 - 1/2 + 1/2 - 1/3 + ...) = 0.5

具体表现：
对于N=1e4：
sum1 ≈ 10000 - 0.5*ln(10000) ≈ 9995.39
sum2 ≈ 10000 - 0.5*ln(10000) ≈ 9995.39
理论差值应为 ≈ 0.5
但实际上计算9995.39 - 9995.39时，会损失约4位有效数字
   - （解释为什么会发生灾难性抵消）
   - 根本原因：
当两个相近的大数相减时，有效数字丢失
在S2中：
sum1和sum2都是O(N)量级,但它们的差是O(1)量级
相对误差 = (Δsum1 + Δsum2)/(sum2 - sum1) ≈ (N*ε)/0.5 = O(Nε)

具体机制：
计算sum1和sum2时各自积累浮点误差（约Nε）
相减时：
假设sum1 = a(1+δ₁), sum2 = b(1+δ₂),其中a≈b≈N，δ≈O(ε)

结果误差：
sum2 - sum1 ≈ (b-a) + (bδ₂ - aδ₁),第一项是真实差值（≈0.5）,第二项是误差项（≈Nε）

### 5.2 误差增长行为
1. 误差与N的幂律关系：
   - （分析双对数图的线性部分）
   - 双对数图的线性部分分析
在双对数坐标（log-log图）中，误差与N的关系表现为：
S1误差曲线:
在N较大时近似水平线（斜率≈0）,表明相对误差基本不随N变化,符合公式：err1 ~ N^0（即与N无关）
S2误差曲线：
呈现明显的直线特征,斜率约为1（45度角）,表明相对误差与N成正比,符合公式：err2 ~ N^1
   - （估算幂指数p）
   - 对于S2的误差增长，可通过线性回归估算p：
     取对数变换：log(err2) = p·log(N) + C
     选择N=1e3和N=1e4两点计算斜率：p ≈ [log(err2@1e4) - log(err2@1e3)] / [log(1e4) - log(1e3)] ≈ 1
典型数值示例：
假设：
N=1e3时 err2=3.2e-13
N=1e4时 err2=3.2e-12
则：
p ≈ log10(3.2e-12 / 3.2e-13) / log10(1e4/1e3) = 1

2. 误差增长原因：
   - （从数值计算角度解释误差增长的原因）
   - S1误差稳定的原因
数值抵消效应：
正负项交替部分抵消了累积误差类似Kahan求和算法的自我校正机制
截断误差主导：误差主要来自最后几项的截断与N无关的固定精度限制
S2误差线性增长的原因:灾难性抵消的放大效应

## 6. 结论
1. 不同计算形式的数值稳定性比较
2. 灾难性抵消对计算精度的影响
3. 数学等价与数值计算的关系

## 7. 思考题
1. 为什么数学上等价的表达式在数值计算中会有如此大的差异？

2. 在实际编程中，如何避免类似的数值不稳定性？

3. 除了本实验中的三种形式，你能想到其他数值更稳定的计算方式吗？

## 附录：关键代码
```python
# 在此粘贴关键代码实现
```
