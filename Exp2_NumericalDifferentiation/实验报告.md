# 实验二：数值微分的误差权衡

## 1. 实验目的
- 理解数值微分中截断误差与舍入误差的权衡关系
- 观察有限差分法计算导数时的误差变化规律
- 分析步长对数值微分精度的影响
- 确定最优步长范围

## 2. 实验方法
### 2.1 理论基础
数值微分是通过有限差分近似导数的计算方法。本实验实现了两种差分方法：
- 前向差分法: $f'(x) \approx \frac{f(x+\delta) - f(x)}{\delta}$
- 中心差分法: $f'(x) \approx \frac{f(x+\delta) - f(x-\delta)}{2\delta}$

### 2.2 测试函数
本实验使用函数 $f(x) = x(x-1)$，其解析导数为 $f'(x) = 2x - 1$。

### 2.3 实验步骤
1. 实现前向差分和中心差分函数
2. 在 $x=1$ 点计算不同步长下的数值导数
3. 计算数值导数与解析导数的相对误差
4. 绘制误差-步长关系图（对数坐标）
5. 分析最优步长和收敛阶数

## 3. 实验结果
### 3.1 数据表格
| 步长(δ) | 前向差分值 | 中心差分值 | 解析解 | 前向差分相对误差 | 中心差分相对误差 |
|---------|------------|------------|--------|------------------|------------------|
| 1.00e-02 |1.000000e-02  |1.000000e-02 | 1.0    |1.000000e-02      |8.881784e-16      |
| 1.00e-04 |1.000000e-04  |1.000000e-04 | 1.0    |1.000000e-04      |1.101341e-13      |
| 1.00e-06 |9.999770e-07  |9.999770e-07 | 1.0    |9.999177e-07      |2.675549e-11      |
| 1.00e-08 |3.922529e-09  |3.922529e-09 | 1.0    |3.922529e-09      |5.263561e-10      |
| 1.00e-10 |8.284037e-08  |8.284037e-08 | 1.0    |8.284037e-08      |8.274037e-08      |
| 1.00e-12 |8.890058e-05  |8.890058e-05 | 1.0    |8.890058e-05      |3.338943e-05      |
| 1.00e-14 |7.992778e-04  |7.992778e-04 | 1.0    |7.992778e-04      |7.992778e-04      |
![image](https://github.com/user-attachments/assets/935b192f-b1fd-4962-9b34-4d4b830e288d)


### 3.2 误差-步长关系图
（在此插入误差-步长关系图，并简要说明图中观察到的现象）
![image](https://github.com/user-attachments/assets/37851537-ff08-4777-aeb2-9b1ca61eff5f)

## 4. 分析与讨论
### 4.1 误差来源分析
数值微分中存在两种主要误差来源：
- **截断误差**：由于使用有限差分近似导数定义引入的误差，通常随步长减小而减小。在实验中，随着步长的减小，截断误差逐渐减小，直到步长达到某个临界值。
- **舍入误差**：由于计算机浮点数表示的有限精度引入的误差，通常随步长减小而增大。在实验中，当步长减小到一定程度后，舍入误差开始主导，导致误差急剧增大。

（分析实验中观察到的截断误差和舍入误差的表现）
实验中观察到的误差表现：
当步长较大时，截断误差占主导，误差较大。
当步长减小时，截断误差减小，但舍入误差开始增大。
当步长减小到某个临界值后，舍入误差占主导，误差急剧增大。

### 4.2 前向差分与中心差分的比较
（比较两种方法的精度差异，并解释原因）
精度差异：中心差分方法的精度通常高于前向差分方法。在实验中，中心差分的相对误差通常比前向差分小，尤其是在较大的步长下。
原因：中心差分使用对称的差分公式，能够更好地抵消某些误差项，从而提高精度。而前向差分仅使用单侧信息，误差项更多。

### 4.3 最优步长分析
（分析实验中观察到的最优步长，并解释为什么存在最优步长）
实验观察：实验中观察到，前向差分和中心差分都有一个最优步长，使得误差最小。
前向差分最优步长：约为 1.00e−08，此时相对误差为 3.922529e−09。
中心差分最优步长：约为 1.00e−02，此时相对误差为 8.881784e−16。
原因：最优步长的存在是由于截断误差和舍入误差之间的权衡。当步长减小时，截断误差减小，但舍入误差增大。存在一个步长使得两种误差的总和最小，这就是最优步长。

### 4.4 收敛阶数分析
（分析两种方法的收敛阶数，并与理论预期进行比较）
前向差分收敛阶数：约为 -0.66。理论上，前向差分的收敛阶数应为 -1.0，但由于舍入误差的影响，实际观测到的收敛阶数略低。
中心差分收敛阶数：约为 -1.10。理论上，中心差分的收敛阶数应为 -2.0，但由于舍入误差的影响，实际观测到的收敛阶数也略低。

## 5. 实验结论
（总结本实验的主要发现，特别是关于误差权衡、最优步长和不同差分方法的优缺点）
误差权衡：数值微分中存在截断误差和舍入误差的权衡，步长的选择需要在这两者之间找到平衡。
最优步长：存在一个最优步长使得误差最小，不同方法的最优步长不同。
方法优缺点：
前向差分：简单易实现，但精度较低，适合对精度要求不高的场景。
中心差分：精度较高，但实现稍复杂，适合对精度要求较高的场景。

## 附录：核心代码片段
```python
# 前向差分法实现
def forward_diff(f, x, delta):
    return (f(x + delta) - f(x)) / delta

# 中心差分法实现
def central_diff(f, x, delta):
    return (f(x + delta) - f(x - delta)) / (2 * delta)

# 计算误差的代码
def calculate_errors(x_point):
    deltas = [1e-2, 1e-4, 1e-6, 1e-8, 1e-10, 1e-12, 1e-14]
    forward_errors = []
    central_errors = []
    
    for delta in deltas:
        forward_approx = forward_diff(f, x_point, delta)
        central_approx = central_diff(f, x_point, delta)
        forward_errors.append(abs(forward_approx - analytical_derivative(x_point)))
        central_errors.append(abs(central_approx - analytical_derivative(x_point)))
    
    return deltas, forward_errors, central_errors

# 绘制误差-步长关系图的代码
def plot_errors(deltas, forward_errors, central_errors):
    import matplotlib.pyplot as plt
    
    plt.figure(figsize=(10, 6))
    plt.loglog(deltas, forward_errors, marker='o', label='前向差分')
    plt.loglog(deltas, central_errors, marker='s', label='中心差分')
    plt.xlabel('步长 δ')
    plt.ylabel('相对误差')
    plt.title('误差与步长的关系')
    plt.legend()
    plt.grid(True)
    plt.show()
```
