# 实验四：调和级数求和顺序与舍入误差实验报告

## 1. 实验目的
1. 实现并比较两种调和级数求和方法
2. 量化分析不同求和顺序导致的计算结果差异
3. 理解浮点数舍入误差的累积效应
4. 探究求和顺序对数值计算精度的影响

## 2. 实验原理
### 2.1 调和级数部分和
调和级数的前N项和定义为：

$$ S_N = \sum_{n=1}^{N} \frac{1}{n} $$

### 2.2 两种求和方法
1. 从小到大求和（ $S^{(up)}$）：

$$ S^{(up)} = \sum_{n=1}^{N}\frac{1}{n} = \frac{1}{1} + \frac{1}{2} + \frac{1}{3} + \cdots + \frac{1}{N} $$

2. 从大到小求和（ $S^{(down)}$）：

$$ S^{(down)} = \sum_{n=N}^{1}\frac{1}{n} = \frac{1}{N} + \frac{1}{N-1} + \cdots + \frac{1}{2} + \frac{1}{1} $$

### 2.3 相对差异计算
两种方法的相对差异定义为：

$$ \delta = \frac{|S^{(up)} - S^{(down)}|}{|(S^{(up)} + S^{(down)}) / 2|} $$

## 3. 实验方法
### 3.1 代码实现
- 实现 `sum_up(N)` 函数，从小到大计算调和级数和
- 实现 `sum_down(N)` 函数，从大到小计算调和级数和

### 3.2 数据收集
对不同的N值进行计算：
1. N值选取：使用 `np.logspace(1, 4, 50)` 在对数尺度上均匀取点
2. 计算并记录相对差异

## 4. 实验结果
### 4.1 数据记录

| N | $S^{(up)}$ | $S^{(down)}$ | 相对差异 δ |
|---|------------|--------------|------------|
| 10 |2.9289682540           |2.9289682540              |0.0000e+00            |
| 100 |5.1873775176          |5.1873775176              |1.7122e-16            |
| 1000 |7.4854708606         |7.4854708606              |3.5596e-16            |
| 10000 |9.7876060360        |9.7876060360              |3.8113e-15            |

### 4.2 误差分析图
![image](https://github.com/user-attachments/assets/d22191b2-6f87-456f-a8c9-89eb38e5646f)



## 5. 分析与讨论
### 5.1 结果分析
1. 相对差异随N的变化趋势：
   - （分析图表趋势）
 图表趋势：
在双对数坐标下，相对差异 δ 随 
N
N 增大呈微弱上升趋势，但整体保持在极低量级（
10
−
15
∼
10
−
16
10 
−15
 ∼10 
−16
 ）。这表明舍入误差随 
N
N 的增大而缓慢积累，但未呈现明显的幂律增长。

2. 舍入误差累积效应：
   - （分析为什么 $S^{(down)}$更精确）
   - 当从大到小求和时（
S
(
d
o
w
n
)
S 
(down)
 ），初始累加的项为较小的值（如 
1
/
N
,
1
/
(
N
−
1
)
1/N,1/(N−1)）。随着累加和逐渐增大，后续加入的项（如 
1
/
2
,
1
/
1
1/2,1/1）对总和的贡献更显著，能有效保留精度。
相反，从小到大求和（
S
(
u
p
)
S 
(up)
 ）时，累加和会迅速增大（例如 
N
=
10
4
N=10 
4
  时，总和约为 
9.78
9.78），后续的小项（如 
1
/
10
4
≈
10
−
4
1/10 
4
 ≈10 
−4
 ）与当前和相加时，由于浮点数尾数位有限（双精度为 52 位），小数部分可能因对齐指数位而被截断，导致精度丢失。
   - （结合浮点数表示方式解释）
   - 以双精度浮点数（IEEE 754）为例，其尾数位数为 52 位，可表示约 16 位有效数字。当两个数的大小差异超过 
2
52
2 
52
  倍时，较小数的加法将完全丢失精度。虽然调和级数的项差异远小于此阈值，但多次累加中的截断误差仍会累积。

### 5.2 误差来源分析
1. 浮点数表示精度限制
2. 加法运算中的舍入
3. 求和顺序的影响

## 6. 结论
（总结实验发现，特别是关于求和顺序对计算精度的影响）
求和顺序对精度的影响：
从大到小求和（
S
(
d
o
w
n
)
S 
(down)
 ）能显著减少舍入误差的累积，尤其在 
N
N 较大时表现更优。

误差增长特性：
相对差异 δ 随 
N
N 增大呈缓慢上升趋势，但受浮点数精度限制，差异量级始终维持在 
10
−
15
∼
10
−
16
10 
−15
 ∼10 
−16
 。

实践建议：
在需要高精度计算的场景中，应优先从数量级较小的项开始累加。
## 7. 思考题
1. 为什么从大到小求和通常能获得更好的精度？
因为先累加小项时，后续的大项能更有效地贡献到总和的高位有效数字，避免因累加和过大导致小项被截断。
2. 在实际应用中，如何选择合适的求和策略来减小舍入误差？
对正数求和时，按升序（从小到大）或分组求和（如 pairwise summation）可优化精度。

对包含正负数的序列，应优先累加绝对值相近的项以减少抵消误差。
3. 除了改变求和顺序，还有什么方法可以提高数值计算的精度？
Kahan 求和算法：通过补偿误差项修正累积误差。

高精度数据类型：使用 decimal 模块或符号计算库。

分块求和：将序列划分为多个块，分别求和后再合并。
## 附录：关键代码
```python
def sum_up(N):
    s = 0.0
    for n in range(1, N+1):
        s += 1.0 / n
    return s

def sum_down(N):
    s = 0.0
    for n in range(N, 0, -1):
        s += 1.0 / n
    return s

def calculate_relative_difference(N):
    s_up = sum_up(N)
    s_down = sum_down(N)
    diff = abs(s_up - s_down)
    avg = (s_up + s_down) / 2
    return diff / avg if avg != 0 else 0.0
# 在此粘贴关键代码实现
```
